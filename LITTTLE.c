#pragma config(Sensor, dgtl1,  topFlyQuad,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  botFlyQuad,     sensorQuadEncoder)
#pragma config(Motor,  port2,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           hopper,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           topFly,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           bottomFly,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

bool hopperEn = false;
bool flywheelEn = false;

int deltaTimeMs = 15;

float topP = 0;
float topI = 0;
float topD = 0;
int topCumError = 0;
int topLastError = 0;
int topSetpoint = 0;
int topPID(float p, float i, float d, int setPoint);
task topPIDTask();

float botP = 0;
float botI = 0;
float botD = 0;
int botCumError = 0;
int botLastError = 0;
int botSetpoint = 0;
int bottomPID(float p, float i, float d, int setPoint);
task bottomPIDTask();

void pre_auton()
{
  bStopTasksBetweenModes = true;
}

task autonomous()
{

}

task usercontrol()
{
	startTask(topPIDTask);
	startTask(bottomPIDTask);

  while (true)
  {
  	motor[backLeft] = vexRT[Ch3];
  	motor[frontLeft] = vexRT[Ch3];

  	motor[backRight] = -vexRT[Ch2];
  	motor[frontRight] = -vexRT[Ch2];

  	if(vexRT[Btn5U] == 1){
  		hopperEn = !hopperEn;
  		delay(25);
  	}

  	if(vexRT[Btn6U] == 1){
  		flywheelEn = !flywheelEn;
  		delay(25);
  	}
  }
}

int topPID(float p, float i, float d, int setPoint){
	int error = setPoint - SensorValue[topFlyQuad];
	topCumError += error;
	int prop = p * error;
	int integral = i * topCumError;
	int derivative = d * ((error - topLastError)/ deltaTimeMs);
	return prop + integral + derivative;
}

int bottomPID(float p, float i, float d, int setPoint){
	int error = setPoint - SensorValue[botFlyQuad];
	botCumError += error;
	int prop = p * error;
	int integral = i * botCumError;
	int derivative = d * ((error - botLastError)/ deltaTimeMs);
	return prop + integral + derivative;
}

task topPIDTask(){
	while(true){
		topPID(topP,topI,topD, topSetpoint);
		wait1Msec(deltaTimeMs);
	}
}

task bottomPIDTask(){
	while(true){
		bottomPID(botP, botI, botD, botSetpoint);
		wait1Msec(deltaTimeMs);
	}
}
